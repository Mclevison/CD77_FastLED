#include "FastLED.h"
#define DATA_PIN    5
#define BUTTON_PIN A5
#define LED_TYPE    WS2812
int x = 0;
#define matrixwidth  8
#define matrixheight 8
#define NUM_LED    matrixwidth*matrixheight
boolean oldState = HIGH;
int     mode     = 0;
CRGB led[NUM_LED];

CRGBPalette16 currentPalettezx;
TBlendType    currentBlendingzx;
void Performance();
void Performance1();
void Performance2();
void Performance3();
void Performance4();
void Performance5();
void Performance6();
void Performance7();

//=======================================
void setup() {
  FastLED.addLeds<LED_TYPE, DATA_PIN>(led, NUM_LED);
  FastLED.setBrightness(255);
}

void loop()
{
  boolean newState = digitalRead(BUTTON_PIN);
  if ((newState == LOW) && (oldState == HIGH)) {
    if (newState == LOW) {     // Yes, still low
      if (++mode > 10) mode = 0; // Advance to next mode, wrap around after #8
      switch (mode) {          // Start the new animation...
          while ( digitalRead(BUTTON_PIN) == 1) {
          case 1:
            Performance();
          } break;
          while ( digitalRead(BUTTON_PIN) == 1) {
          case 2:
            Performance1();
          } break;
          while ( digitalRead(BUTTON_PIN) == 1) {
          case 3:
            Performance2();
          } break;
          while ( digitalRead(BUTTON_PIN) == 1) {
          case 4:
            Performance3();
          } break;
          while ( digitalRead(BUTTON_PIN) == 1) {
          case 5:
            Performance4();
          } break;
          while ( digitalRead(BUTTON_PIN) == 1) {
          case 6:
            Performance5();
          } break;
          while ( digitalRead(BUTTON_PIN) == 1) {
          case 7:
            Performance6();
          } break;
          while ( digitalRead(BUTTON_PIN) == 1) {
          case 8:
            Performance7();
          } break;
      }
    }
  }
}

//=====================palettes=================

const TProgmemPalette16 test_PaletteRWB3_p PROGMEM =
{
  CRGB::Red,
  CRGB::Red,
  CRGB::Red,
  CRGB::Red,

  CRGB::Grey,
  CRGB::Grey,
  CRGB::Grey,
  CRGB::Grey,

  CRGB::Blue,
  CRGB::Blue,
  CRGB::Blue,
  CRGB::Blue,

  CRGB::Red,
  CRGB::Red,
  CRGB::Blue,
  CRGB::Blue
};

void Performance()
{ uint8_t secondHand = 15;
  if ( secondHand == 15)    {
    cd77_matrix_sinewave(3, 0, 60, 7);
  }

  FastLED.show();
}
void Performance1()
{ uint8_t secondHand = 20;
  if ( secondHand == 20) {
    cd77_matrix_sinewave_beatsin(3, 20,  0,  160, 7);
  }
  FastLED.show();
}

void Performance2()
{ uint8_t secondHand = 25;
  if ( secondHand == 25)   {
    cd77_matrix_sinewave_palette(3, 0, 24, 7);
    currentPalettezx = RainbowColors_p;
    currentBlendingzx = NOBLEND;
  }
  FastLED.show();
}

void Performance3()
{ uint8_t secondHand = 30;
  if ( secondHand == 30)   {
    cd77_matrix_sinewave_palette(3, 0, 24, 7);
    currentPalettezx = test_PaletteRWB3_p;
    currentBlendingzx = NOBLEND;
  }
  FastLED.show();
}
void Performance4()
{ uint8_t secondHand = 35;
  if ( secondHand == 135)   {
    cd77_matrix_sinewave_r90(3, 0, 60, 7);
  }
  FastLED.show();
}

void Performance5()
{ uint8_t secondHand = 40;
  if ( secondHand == 40)   {
    cd77_matrix_sinewave_beatsin_r90(3, 20,  0,  160, 7);
  }
  FastLED.show();
}

void Performance6()
{ uint8_t secondHand = 45;
  if ( secondHand == 45)  {
    cd77_matrix_sinewave_palette_r90(3, 0, 24, 7);
    currentPalettezx = RainbowColors_p;
    currentBlendingzx = NOBLEND;
  }
  FastLED.show();
}

void Performance7()
{ uint8_t secondHand = 50;
  if ( secondHand == 50)   {
    cd77_matrix_sinewave_palette_r90(3, 0, 24, 7);
    currentPalettezx = test_PaletteRWB3_p;
    currentBlendingzx = NOBLEND;
  }
  FastLED.show();
}
//=== array for rotating sinewave ==================

uint8_t array1[] = {0, 8, 16, 24, 32, 40, 48, 56,
                    1, 9, 17, 25, 33, 41, 49, 57,
                    2, 10, 18, 26, 34, 42, 50, 58,
                    3, 11, 19, 27, 35, 43, 51, 59,
                    4, 12, 20, 28, 36, 44, 52, 60,
                    5, 13, 21, 29, 37, 45, 53, 61,
                    6, 14, 22, 30, 38, 46, 54, 62,
                    7, 15, 23, 31, 39, 47, 55, 63
                   };

//==================================

void cd77_matrix_sinewave(uint16_t z, uint16_t hue, uint16_t deltahue, uint8_t wait ) {


  fadeToBlackBy( led, NUM_LED, 150);
  for (uint16_t width = 0; width < matrixwidth; width++) {
    led[(NUM_LED - 1) - ((sin8(x + (width * 10 * z)) / 32)*matrixwidth + width)] = CHSV(hue, 255, 255);
    hue += deltahue;

  }
  FastLED.show();
  FastLED.delay(wait); //use along with next line to get desired speed
  x = x + 2; //change 2 to higher number to make go faster
}

//===================================

void cd77_matrix_sinewave_beatsin(uint16_t z, uint8_t beat,  uint8_t c1, uint8_t c2, uint8_t wait ) {
  fadeToBlackBy( led, NUM_LED, 150);
  for (uint16_t width = 0; width < matrixwidth; width++) {
    uint8_t hue = beatsin16(beat, c1, c2);
    led[(NUM_LED - 1) - ((sin8(x + (width * 10 * z)) / 32)*matrixwidth + width)] = CHSV(hue, 255, 255);


  }
  FastLED.show();
  FastLED.delay(wait); //use along with next line to get desired speed
  x = x + 2; //change 2 to higher number to make go faster
}

//===================================

void cd77_matrix_sinewave_palette(uint16_t z, uint8_t colorIndex, uint8_t deltacolorIndex, uint8_t wait ) {


  fadeToBlackBy( led, NUM_LED, 150);
  for (uint16_t width = 0; width < matrixheight; width++) {

    led[(NUM_LED - 1) - ((sin8(x + (width * 10 * z)) / 32)*matrixwidth + width)] = ColorFromPalette( currentPalettezx, colorIndex + sin8(x), 255, currentBlendingzx);

    colorIndex += deltacolorIndex;
  }
  FastLED.show();
  FastLED.delay(wait); //use along with next line to get desired speed
  x = x + 2; //change 2 to higher number to make go faster
}
void cd77_matrix_sinewave_r90(uint16_t z, uint8_t hue, uint8_t deltahue, uint8_t wait ) {
  fadeToBlackBy( led, NUM_LED, 150);
  for (uint16_t width = 0; width < matrixwidth; width++) {
    led[array1[(NUM_LED - 1) - ((sin8(x + (width * 10 * z)) / 32)*matrixwidth + width)]] = CHSV(hue, 255, 255);
    hue += deltahue;

  }
  FastLED.show();
  FastLED.delay(wait); //use along with next line to get desired speed
  x = x + 2; //change 2 to higher number to make go faster
}

//========================================

void cd77_matrix_sinewave_beatsin_r90(uint16_t z, uint8_t beat,  uint8_t c1, uint8_t c2, uint8_t wait ) {
  fadeToBlackBy( led, NUM_LED, 150);
  for (uint16_t width = 0; width < matrixwidth; width++) {
    uint8_t hue = beatsin16(beat, c1, c2);
    led[array1[(NUM_LED - 1) - ((sin8(x + (width * 10 * z)) / 32)*matrixwidth + width)]] = CHSV(hue, 255, 255);


  }
  FastLED.show();
  FastLED.delay(wait); //use along with next line to get desired speed
  x = x + 2; //change 2 to higher number to make go faster
}

//==========================================

void cd77_matrix_sinewave_palette_r90(uint16_t z, uint8_t colorIndex, uint8_t deltacolorIndex, uint8_t wait ) {
  fadeToBlackBy( led, NUM_LED, 150);
  for (uint16_t width = 0; width < matrixwidth; width++) {

    led[array1[(NUM_LED - 1) - ((sin8(x + (width * 10 * z)) / 32)*matrixwidth + width)]] = ColorFromPalette( currentPalettezx, colorIndex + sin8(x), 255, currentBlendingzx);

    colorIndex += deltacolorIndex;
  }
  FastLED.show();
  FastLED.delay(wait); //use along with next line to get desired speed
  x = x + 2; //change 2 to higher number to make go faster
}
